{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nimport throttle from 'lodash.throttle';\nimport warn from 'warning';\nimport Node from './GraphNode';\nimport { instancedExt, MaterialNode } from '.';\nimport { PointLights } from '../lights';\nimport { CameraNode } from './CameraNode';\nimport { GeometryNode } from './GeometryNode';\nimport { InstancedNode } from './InstancedNode';\nexport var isSceneNode = Symbol('isSceneNode');\nfunction getMode(gl, modeString) {\n  if (!modeString) {\n    return gl.TRIANGLES;\n  }\n  switch (modeString) {\n    case 'TRIANGLES':\n      return gl.TRIANGLES;\n    case 'LINES':\n      return gl.LINES;\n    case 'POINTS':\n      return gl.POINTS;\n    case 'LINE_STRIP':\n      return gl.LINE_STRIP;\n    case 'LINE_LOOP':\n      return gl.LINE_LOOP;\n    case 'TRIANGLE_STRIP':\n      return gl.TRIANGLE_STRIP;\n    case 'TRIANGLE_FAN':\n      return gl.TRIANGLE_FAN;\n    default:\n      return gl.TRIANGLES;\n  }\n}\nexport var SceneNode = /*#__PURE__*/function (_Node) {\n  var _s = $RefreshSig$();\n  _inherits(SceneNode, _Node);\n  var _super = _createSuper(SceneNode);\n  function SceneNode(canvas, extensions, _gl) {\n    var _this;\n    _classCallCheck(this, SceneNode);\n    _this = _super.call(this);\n    _this.context = void 0;\n    _this.element = void 0;\n    _this.maxTextures = void 0;\n    _this.extensions = void 0;\n    _this[isSceneNode] = true;\n    _this.renderOnUpdate = false;\n    _this.webglVersion = 1;\n    _this.pointLights = new PointLights();\n    _this.clearColor = [0, 0, 0, 0];\n    _this.textureUnits = {};\n    _this.materialMap = new WeakMap();\n    _this.activeAttribCount = 0;\n    _this.activeAttributes = null;\n    _this.render = function () {\n      var gl = _this.context;\n      gl.enable(gl.DEPTH_TEST);\n      gl.clearColor.apply(gl, _toConsumableArray(_this.clearColor));\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n      Object.keys(_this.textureUnits).forEach(function (unit) {\n        if (_this.textureUnits[unit] !== false) {\n          /* @ts-ignore */\n          gl.activeTexture(gl[\"TEXTURE\".concat(unit)]);\n          gl.bindTexture(gl.TEXTURE_2D, _this.textureUnits[unit]);\n        }\n      });\n      var needsMatrixUpdate = _this.needsMatrixUpdate === true;\n      if (needsMatrixUpdate) {\n        _this.updateMatrix();\n        _this.updateWorldMatrix();\n        _this.needsMatrixUpdate = false;\n      }\n      for (var i = 0; i < _this.children.length; i++) {\n        _this.renderNode(_this.children[i], null, null, needsMatrixUpdate);\n      }\n    };\n    _this.requestRender = throttle(_this.render, 17);\n    _this.context = _gl;\n    _this.element = canvas;\n    _this.maxTextures = _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS);\n    _this.extensions = extensions.reduce(function (acc, ext) {\n      acc[ext] = _gl.getExtension(ext);\n      return acc;\n    }, {});\n    return _this;\n  }\n  _createClass(SceneNode, [{\n    key: \"getTextureUnit\",\n    value: function getTextureUnit(texture) {\n      for (var _unit = 0; _unit < this.maxTextures; _unit++) {\n        if (this.textureUnits[_unit] === undefined) {\n          this.textureUnits[_unit] = texture || false;\n          return _unit;\n        }\n      }\n      warn(false, \"Max textures(\".concat(this.maxTextures, \") exceeded.\"));\n      return this.maxTextures - 1;\n    }\n  }, {\n    key: \"releaseTextureUnit\",\n    value: function releaseTextureUnit(unit) {\n      delete this.textureUnits[unit];\n    }\n  }, {\n    key: \"setMaterial\",\n    value: function setMaterial(gl, _ref) {\n      var program = _ref.program;\n      if (!program) {\n        throw Error('Encountered material with no program.');\n      }\n      var material = this.materialMap.get(program);\n      if (material) {\n        return material;\n      }\n      var attributes = {};\n      var attribCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n      for (var i = attribCount - 1; i >= 0; i--) {\n        var attr = gl.getActiveAttrib(program, i);\n        if (attr) {\n          attributes[attr.name] = gl.getAttribLocation(program, attr.name);\n        } else {\n          warn(false, 'Encountered invalid attribute index.');\n        }\n      }\n      var uniforms = {\n        v: gl.getUniformLocation(program, 'viewMatrix'),\n        m: gl.getUniformLocation(program, 'modelMatrix'),\n        p: gl.getUniformLocation(program, 'projectionMatrix')\n      };\n      material = {\n        program: program,\n        uniforms: uniforms,\n        attributes: attributes,\n        attribCount: attribCount\n      };\n      this.materialMap.set(program, material);\n      return material;\n    }\n  }, {\n    key: \"renderNode\",\n    value: _s(function renderNode(node, activeCamera, activeMaterial, needsMatrixUpdate) {\n      _s();\n      var gl = this.context; // *************************************************\n      // UPDATE MATRIX IF NEEDED\n      // *************************************************\n\n      needsMatrixUpdate = needsMatrixUpdate || node.needsMatrixUpdate === true;\n      if (needsMatrixUpdate) {\n        node.updateMatrix();\n        node.updateWorldMatrix();\n        node.needsMatrixUpdate = false;\n      } // *************************************************\n      // HANDLE CAMERA\n      // *************************************************\n\n      if (node instanceof CameraNode) {\n        activeCamera = node;\n      } // *************************************************\n      // HANDLE MATERIAL\n      // *************************************************\n\n      if (node instanceof MaterialNode) {\n        var nextMaterial = this.setMaterial(gl, node); // note: buffers are deleted when no longer in use by the buffer\n        // hooks. So we to disable attribute indexes no longer in use or it\n        // will throw an error about no buffer being bound to the index.\n\n        var diff = this.activeAttribCount - nextMaterial.attribCount;\n        if (diff > 0) {\n          for (var i = 0; i < diff; i++) {\n            gl.disableVertexAttribArray(nextMaterial.attribCount + i);\n          }\n        }\n        this.activeAttribCount = nextMaterial.attribCount;\n        this.activeAttributes = null;\n        activeMaterial = nextMaterial;\n        gl.useProgram(activeMaterial.program);\n        if (activeCamera) {\n          var _activeCamera = activeCamera,\n            view = _activeCamera.view,\n            projection = _activeCamera.projection;\n          gl.uniformMatrix4fv(activeMaterial.uniforms.v, false, view);\n          gl.uniformMatrix4fv(activeMaterial.uniforms.p, false, projection);\n        }\n      } // *************************************************\n      // HANDLE GEOMETRY\n      // *************************************************\n\n      if (node instanceof GeometryNode) {\n        if (activeMaterial) {\n          gl.useProgram(activeMaterial.program);\n          if (node.attributes !== this.activeAttributes) {\n            for (var attr in activeMaterial.attributes) {\n              var location = activeMaterial.attributes[attr];\n              node.attributes[attr](location);\n            }\n            this.activeAttributes = node.attributes;\n          }\n          gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix);\n          if (node.drawArrays) {\n            gl.drawArrays(getMode(gl, node.drawArrays.mode), node.drawArrays.first || 0, node.drawArrays.count);\n          } else if (node.drawElements) {\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index);\n            gl.drawElements(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ?\n            // @ts-ignore\n            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0);\n          }\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n          gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        }\n      } // *************************************************\n      // HANDLE INSTANCED GEOMETRY\n      // *************************************************\n\n      if (node instanceof InstancedNode) {\n        if (activeMaterial) {\n          gl.useProgram(activeMaterial.program);\n          if (this.extensions[instancedExt] === undefined) {\n            this.extensions[instancedExt] = gl.getExtension(instancedExt);\n          }\n          var ext = this.extensions[instancedExt];\n          if (node.attributes !== this.activeAttributes) {\n            for (var _attr in activeMaterial.attributes) {\n              var _location = activeMaterial.attributes[_attr];\n              node.attributes[_attr](_location, ext, this.webglVersion);\n            }\n            this.activeAttributes = node.attributes;\n          }\n          gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix);\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index);\n          if (this.webglVersion === 2 && node.drawElements) {\n            // @ts-ignore\n            gl.drawElementsInstanced(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ?\n            // @ts-ignore\n            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0, node.drawElements.primcount);\n          } else if (node.drawElements) {\n            ext.drawElementsInstancedANGLE(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ?\n            // @ts-ignore\n            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0, node.drawElements.primcount);\n          }\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n          gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        }\n      }\n      for (var _i = 0; _i < node.children.length; _i++) {\n        this.renderNode(node.children[_i], activeCamera, activeMaterial, needsMatrixUpdate);\n      }\n    }, \"hr0vFjrcHzdGE5neA/n1HaXK8d0=\", false, function () {\n      return [gl.useProgram, gl.useProgram, gl.useProgram];\n    })\n  }]);\n  return SceneNode;\n}(Node);","map":{"version":3,"mappings":"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","names":["throttle","warn","Node","instancedExt","MaterialNode","PointLights","CameraNode","GeometryNode","InstancedNode","isSceneNode","Symbol","getMode","gl","modeString","TRIANGLES","LINES","POINTS","LINE_STRIP","LINE_LOOP","TRIANGLE_STRIP","TRIANGLE_FAN","SceneNode","_inherits","canvas","extensions","_classCallCheck","_this","context","element","maxTextures","renderOnUpdate","webglVersion","pointLights","clearColor","textureUnits","materialMap","WeakMap","activeAttribCount","activeAttributes","render","enable","DEPTH_TEST","viewport","width","height","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","Object","keys","forEach","unit","activeTexture","bindTexture","TEXTURE_2D","needsMatrixUpdate","updateMatrix","updateWorldMatrix","i","children","length","renderNode","requestRender","getParameter","MAX_TEXTURE_IMAGE_UNITS","reduce","acc","ext","getExtension","_createClass","key","value","texture","undefined","program","Error","material","get","attributes","attribCount","getProgramParameter","ACTIVE_ATTRIBUTES","attr","getActiveAttrib","name","getAttribLocation","uniforms","v","getUniformLocation","m","p","set","node","activeCamera","activeMaterial","nextMaterial","setMaterial","diff","disableVertexAttribArray","useProgram","view","projection","uniformMatrix4fv","location","worldMatrix","drawArrays","mode","first","count","drawElements","bindBuffer","ELEMENT_ARRAY_BUFFER","index","type","UNSIGNED_SHORT","offset","ARRAY_BUFFER","drawElementsInstanced","primcount","drawElementsInstancedANGLE"],"sources":["/Users/meishenyin/Desktop/Westcliff/3apps/src/spheres/node_modules/@react-vertex/core/src/sceneGraph/SceneNode.ts"],"sourcesContent":["import throttle from 'lodash.throttle'\nimport warn from 'warning'\nimport Node from './GraphNode'\nimport { instancedExt, MaterialNode } from '.'\nimport { PointLights } from '../lights'\nimport {\n  GLContext,\n  DrawMode,\n  RenderMaterial,\n  GeometryAttributes,\n} from '../types'\nimport GraphNode from './GraphNode'\nimport { CameraNode } from './CameraNode'\nimport { GeometryNode } from './GeometryNode'\nimport { InstancedNode } from './InstancedNode'\n\nexport const isSceneNode = Symbol('isSceneNode')\n\nfunction getMode(gl: GLContext, modeString: DrawMode) {\n  if (!modeString) {\n    return gl.TRIANGLES\n  }\n\n  switch (modeString) {\n    case 'TRIANGLES':\n      return gl.TRIANGLES\n    case 'LINES':\n      return gl.LINES\n    case 'POINTS':\n      return gl.POINTS\n    case 'LINE_STRIP':\n      return gl.LINE_STRIP\n    case 'LINE_LOOP':\n      return gl.LINE_LOOP\n    case 'TRIANGLE_STRIP':\n      return gl.TRIANGLE_STRIP\n    case 'TRIANGLE_FAN':\n      return gl.TRIANGLE_FAN\n    default:\n      return gl.TRIANGLES\n  }\n}\n\nexport class SceneNode extends Node {\n  context: GLContext\n  element: HTMLCanvasElement\n  maxTextures: number\n  extensions: { [key: string]: any }\n  constructor(canvas: HTMLCanvasElement, extensions: string[], gl: GLContext) {\n    super()\n\n    this.context = gl\n    this.element = canvas\n\n    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)\n\n    this.extensions = extensions.reduce((acc, ext) => {\n      acc[ext] = gl.getExtension(ext)\n      return acc\n    }, {} as any)\n  }\n\n  [isSceneNode] = true\n  renderOnUpdate = false\n  webglVersion = 1\n\n  pointLights = new PointLights()\n  clearColor: number[] = [0, 0, 0, 0]\n\n  textureUnits: { [unit: string]: WebGLTexture | false } = {}\n\n  getTextureUnit(texture?: WebGLTexture | null) {\n    for (let unit = 0; unit < this.maxTextures; unit++) {\n      if (this.textureUnits[unit] === undefined) {\n        this.textureUnits[unit] = texture || false\n        return unit\n      }\n    }\n\n    warn(false, `Max textures(${this.maxTextures}) exceeded.`)\n\n    return this.maxTextures - 1\n  }\n\n  releaseTextureUnit(unit: number) {\n    delete this.textureUnits[unit]\n  }\n\n  materialMap = new WeakMap<WebGLProgram, RenderMaterial>()\n\n  setMaterial(gl: GLContext, { program }: MaterialNode) {\n    if (!program) {\n      throw Error('Encountered material with no program.')\n    }\n\n    let material = this.materialMap.get(program)\n\n    if (material) {\n      return material\n    }\n\n    const attributes: { [name: string]: number } = {}\n\n    const attribCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES)\n\n    for (let i = attribCount - 1; i >= 0; i--) {\n      const attr = gl.getActiveAttrib(program, i)\n\n      if (attr) {\n        attributes[attr.name] = gl.getAttribLocation(program, attr.name)\n      } else {\n        warn(false, 'Encountered invalid attribute index.')\n      }\n    }\n\n    const uniforms = {\n      v: gl.getUniformLocation(program, 'viewMatrix'),\n      m: gl.getUniformLocation(program, 'modelMatrix'),\n      p: gl.getUniformLocation(program, 'projectionMatrix'),\n    }\n\n    material = { program, uniforms, attributes, attribCount }\n\n    this.materialMap.set(program, material)\n\n    return material\n  }\n\n  activeAttribCount = 0\n  activeAttributes: GeometryAttributes | null = null\n\n  render = () => {\n    const gl = this.context\n\n    gl.enable(gl.DEPTH_TEST)\n    gl.clearColor(...(this.clearColor as [number, number, number, number]))\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n\n    Object.keys(this.textureUnits).forEach(unit => {\n      if (this.textureUnits[unit] !== false) {\n        /* @ts-ignore */\n        gl.activeTexture(gl[`TEXTURE${unit}`])\n        gl.bindTexture(gl.TEXTURE_2D, this.textureUnits[unit])\n      }\n    })\n\n    const needsMatrixUpdate = this.needsMatrixUpdate === true\n\n    if (needsMatrixUpdate) {\n      this.updateMatrix()\n      this.updateWorldMatrix()\n      this.needsMatrixUpdate = false\n    }\n\n    for (let i = 0; i < this.children.length; i++) {\n      this.renderNode(this.children[i], null, null, needsMatrixUpdate)\n    }\n  }\n\n  requestRender: () => void = throttle(this.render, 17)\n\n  renderNode(\n    node: GraphNode,\n    activeCamera: CameraNode | null,\n    activeMaterial: RenderMaterial | null,\n    needsMatrixUpdate: boolean,\n  ) {\n    const gl = this.context\n\n    // *************************************************\n    // UPDATE MATRIX IF NEEDED\n    // *************************************************\n    needsMatrixUpdate = needsMatrixUpdate || node.needsMatrixUpdate === true\n\n    if (needsMatrixUpdate) {\n      node.updateMatrix()\n      node.updateWorldMatrix()\n      node.needsMatrixUpdate = false\n    }\n\n    // *************************************************\n    // HANDLE CAMERA\n    // *************************************************\n\n    if (node instanceof CameraNode) {\n      activeCamera = node\n    }\n\n    // *************************************************\n    // HANDLE MATERIAL\n    // *************************************************\n\n    if (node instanceof MaterialNode) {\n      const nextMaterial = this.setMaterial(gl, node)\n\n      // note: buffers are deleted when no longer in use by the buffer\n      // hooks. So we to disable attribute indexes no longer in use or it\n      // will throw an error about no buffer being bound to the index.\n      const diff = this.activeAttribCount - nextMaterial.attribCount\n\n      if (diff > 0) {\n        for (let i = 0; i < diff; i++) {\n          gl.disableVertexAttribArray(nextMaterial.attribCount + i)\n        }\n      }\n\n      this.activeAttribCount = nextMaterial.attribCount\n      this.activeAttributes = null\n\n      activeMaterial = nextMaterial\n\n      gl.useProgram(activeMaterial.program)\n\n      if (activeCamera) {\n        const { view, projection } = activeCamera\n\n        gl.uniformMatrix4fv(activeMaterial.uniforms.v, false, view)\n        gl.uniformMatrix4fv(activeMaterial.uniforms.p, false, projection)\n      }\n    }\n\n    // *************************************************\n    // HANDLE GEOMETRY\n    // *************************************************\n\n    if (node instanceof GeometryNode) {\n      if (activeMaterial) {\n        gl.useProgram(activeMaterial.program)\n\n        if (node.attributes !== this.activeAttributes) {\n          for (const attr in activeMaterial.attributes) {\n            const location = activeMaterial.attributes[attr]\n            node.attributes[attr](location)\n          }\n\n          this.activeAttributes = node.attributes\n        }\n\n        gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix)\n\n        if (node.drawArrays) {\n          gl.drawArrays(\n            getMode(gl, node.drawArrays.mode),\n            node.drawArrays.first || 0,\n            node.drawArrays.count,\n          )\n        } else if (node.drawElements) {\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index)\n\n          gl.drawElements(\n            getMode(gl, node.drawElements.mode),\n            node.drawElements.count,\n            node.drawElements.type\n              ? // @ts-ignore\n                gl[node.drawElements.type]\n              : gl.UNSIGNED_SHORT,\n            node.drawElements.offset || 0,\n          )\n        }\n\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)\n        gl.bindBuffer(gl.ARRAY_BUFFER, null)\n      }\n    }\n\n    // *************************************************\n    // HANDLE INSTANCED GEOMETRY\n    // *************************************************\n\n    if (node instanceof InstancedNode) {\n      if (activeMaterial) {\n        gl.useProgram(activeMaterial.program)\n\n        if (this.extensions[instancedExt] === undefined) {\n          this.extensions[instancedExt] = gl.getExtension(instancedExt)\n        }\n\n        const ext = this.extensions[instancedExt]\n\n        if (node.attributes !== this.activeAttributes) {\n          for (const attr in activeMaterial.attributes) {\n            const location = activeMaterial.attributes[attr]\n            node.attributes[attr](location, ext, this.webglVersion)\n          }\n\n          this.activeAttributes = node.attributes\n        }\n\n        gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix)\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index)\n\n        if (this.webglVersion === 2 && node.drawElements) {\n          // @ts-ignore\n          gl.drawElementsInstanced(\n            getMode(gl, node.drawElements.mode),\n            node.drawElements.count,\n            node.drawElements.type\n              ? // @ts-ignore\n                gl[node.drawElements.type]\n              : gl.UNSIGNED_SHORT,\n            node.drawElements.offset || 0,\n            node.drawElements.primcount,\n          )\n        } else if (node.drawElements) {\n          ext.drawElementsInstancedANGLE(\n            getMode(gl, node.drawElements.mode),\n            node.drawElements.count,\n            node.drawElements.type\n              ? // @ts-ignore\n                gl[node.drawElements.type]\n              : gl.UNSIGNED_SHORT,\n            node.drawElements.offset || 0,\n            node.drawElements.primcount,\n          )\n        }\n\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)\n        gl.bindBuffer(gl.ARRAY_BUFFER, null)\n      }\n    }\n\n    for (let i = 0; i < node.children.length; i++) {\n      this.renderNode(\n        node.children[i],\n        activeCamera,\n        activeMaterial,\n        needsMatrixUpdate,\n      )\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}