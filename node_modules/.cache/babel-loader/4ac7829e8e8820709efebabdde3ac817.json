{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nimport React, { Component, createRef } from 'react';\nimport ReactVertexReconciler, { SceneNode } from './Reconciler';\nimport ReactVertexContext from './Context';\nvar Canvas = /*#__PURE__*/function (_Component) {\n  _inherits(Canvas, _Component);\n  var _super = _createSuper(Canvas);\n  function Canvas() {\n    var _this;\n    _classCallCheck(this, Canvas);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.sceneNode = void 0;\n    _this.state = {\n      error: false,\n      message: ''\n    };\n    _this.canvas = /*#__PURE__*/createRef();\n    _this.container = void 0;\n    _this.contextObject = void 0;\n    _this.renderScene = function () {\n      if (_this.sceneNode) {\n        _this.sceneNode.render();\n      }\n    };\n    return _this;\n  }\n  _createClass(Canvas, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var current = this.canvas.current;\n      var _this$props = this.props,\n        _this$props$webgl = _this$props.webgl1,\n        webgl1 = _this$props$webgl === void 0 ? true : _this$props$webgl,\n        _this$props$webgl2 = _this$props.webgl2,\n        webgl2 = _this$props$webgl2 === void 0 ? false : _this$props$webgl2,\n        _this$props$clearColo = _this$props.clearColor,\n        clearColor = _this$props$clearColo === void 0 ? [0, 0, 0, 1] : _this$props$clearColo,\n        children = _this$props.children,\n        _this$props$antialias = _this$props.antialias,\n        antialias = _this$props$antialias === void 0 ? false : _this$props$antialias,\n        _this$props$textureFl = _this$props.textureFlip,\n        textureFlip = _this$props$textureFl === void 0 ? true : _this$props$textureFl,\n        _this$props$contextAt = _this$props.contextAttrs,\n        contextAttrs = _this$props$contextAt === void 0 ? {} : _this$props$contextAt,\n        _this$props$extension = _this$props.extensions,\n        extensions = _this$props$extension === void 0 ? [] : _this$props$extension,\n        _this$props$renderOnU = _this$props.renderOnUpdate,\n        renderOnUpdate = _this$props$renderOnU === void 0 ? false : _this$props$renderOnU;\n      var attrs = _objectSpread({\n        antialias: antialias\n      }, contextAttrs);\n      if (!current) {\n        return;\n      }\n      var gl, webglVersion;\n      if (webgl2) {\n        gl = current.getContext('webgl2', attrs);\n        webglVersion = 2;\n      }\n      if (!gl && webgl1) {\n        gl = current.getContext('webgl', attrs);\n        webglVersion = 1;\n      }\n      if (!gl) {\n        this.setState({\n          error: true,\n          message: 'Could not create WebGL context.'\n        });\n        return;\n      }\n      textureFlip && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n      this.sceneNode = new SceneNode(current, extensions, gl);\n      if (typeof webglVersion === 'number') {\n        this.sceneNode.webglVersion = webglVersion;\n      }\n      this.sceneNode.clearColor = clearColor;\n      this.sceneNode.renderOnUpdate = renderOnUpdate;\n      if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object') {\n        // @ts-ignore\n        window.sceneNode = this.sceneNode;\n      }\n      var update = this.updateDimensions();\n      if (update) {\n        this.contextObject = {\n          scene: this.sceneNode,\n          width: update.width,\n          height: update.height\n        };\n      }\n      this.container = ReactVertexReconciler.createContainer(this.sceneNode, false, false);\n      if (this.contextObject) {\n        ReactVertexReconciler.updateContainer( /*#__PURE__*/React.createElement(ReactVertexContext.Provider, {\n          value: this.contextObject\n        }, children), this.container, this, function () {});\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var children = this.props.children;\n      var dims = this.updateDimensions();\n      if (dims && dims.update && this.contextObject) {\n        this.contextObject = _objectSpread(_objectSpread({}, this.contextObject), {}, {\n          width: dims.width,\n          height: dims.height\n        });\n      }\n      if (this.container && this.contextObject) {\n        ReactVertexReconciler.updateContainer( /*#__PURE__*/React.createElement(ReactVertexContext.Provider, {\n          value: this.contextObject\n        }, children), this.container, this, function () {});\n      }\n    }\n  }, {\n    key: \"updateDimensions\",\n    value: function updateDimensions() {\n      var current = this.canvas.current;\n      if (!current) {\n        return;\n      }\n      var _this$props2 = this.props,\n        width = _this$props2.width,\n        height = _this$props2.height,\n        renderOnResize = _this$props2.renderOnResize;\n      var devicePixelRatio = window.devicePixelRatio || 1;\n      var nextWidth = Math.round(width * devicePixelRatio);\n      var nextHeight = Math.round(height * devicePixelRatio);\n      var update = nextWidth !== current.width || nextHeight !== current.height;\n      if (update) {\n        current.style.width = \"\".concat(width, \"px\");\n        current.style.height = \"\".concat(height, \"px\");\n        current.width = nextWidth;\n        current.height = nextHeight;\n        renderOnResize && this.sceneNode && this.sceneNode.requestRender();\n      }\n      return {\n        width: nextWidth,\n        height: nextHeight,\n        update: update\n      };\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.container) {\n        ReactVertexReconciler.updateContainer(null, this.container, this, function () {});\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props3 = this.props,\n        _this$props3$canvasCl = _this$props3.canvasClass,\n        canvasClass = _this$props3$canvasCl === void 0 ? '' : _this$props3$canvasCl,\n        _this$props3$canvasSt = _this$props3.canvasStyle,\n        canvasStyle = _this$props3$canvasSt === void 0 ? {} : _this$props3$canvasSt;\n      return /*#__PURE__*/React.createElement(\"canvas\", {\n        ref: this.canvas,\n        className: canvasClass,\n        style: canvasStyle\n      });\n    }\n  }]);\n  return Canvas;\n}(Component);\nexport { Canvas as default };","map":{"version":3,"mappings":"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","names":["React","Component","createRef","ReactVertexReconciler","SceneNode","ReactVertexContext","Canvas","sceneNode","state","error","message","canvas","container","contextObject","renderScene","_this","render","current","props","_this$props$webgl","webgl1","_this$props$webgl2","webgl2","_this$props$clearColo","clearColor","children","_this$props$antialias","antialias","_this$props$textureFl","textureFlip","_this$props$contextAt","contextAttrs","_this$props$extension","extensions","_this$props$renderOnU","renderOnUpdate","attrs","gl","webglVersion","getContext","setState","pixelStorei","UNPACK_FLIP_Y_WEBGL","window","update","updateDimensions","scene","width","height","createContainer","updateContainer","Provider","value","dims","renderOnResize","devicePixelRatio","nextWidth","Math","round","nextHeight","style","requestRender","_this$props3$canvasCl","canvasClass","_this$props3$canvasSt","canvasStyle","ref","className"],"sources":["/Users/meishenyin/Desktop/Westcliff/3apps/src/spheres/node_modules/@react-vertex/core/src/Canvas.tsx"],"sourcesContent":["import ReactReconciler from 'react-reconciler'\nimport React, { Component, createRef } from 'react'\nimport ReactVertexReconciler, { SceneNode } from './Reconciler'\nimport ReactVertexContext from './Context'\n\nimport { CanvasProps } from './types'\n\nexport default class Canvas extends Component<CanvasProps> {\n  sceneNode?: SceneNode\n\n  state = {\n    error: false,\n    message: '',\n  }\n\n  canvas = createRef<HTMLCanvasElement>()\n  container?: ReactReconciler.FiberRoot\n  contextObject?: {\n    scene: SceneNode\n    width: number\n    height: number\n  }\n\n  componentDidMount() {\n    const { current } = this.canvas\n    const {\n      webgl1 = true,\n      webgl2 = false,\n      clearColor = [0, 0, 0, 1],\n      children,\n      antialias = false,\n      textureFlip = true,\n      contextAttrs = {},\n      extensions = [],\n      renderOnUpdate = false,\n    } = this.props\n\n    const attrs = { antialias, ...contextAttrs }\n\n    if (!current) {\n      return\n    }\n\n    let gl, webglVersion\n\n    if (webgl2) {\n      gl = current.getContext('webgl2', attrs)\n      webglVersion = 2\n    }\n\n    if (!gl && webgl1) {\n      gl = current.getContext('webgl', attrs)\n      webglVersion = 1\n    }\n\n    if (!gl) {\n      this.setState({ error: true, message: 'Could not create WebGL context.' })\n      return\n    }\n\n    textureFlip && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)\n\n    this.sceneNode = new SceneNode(current, extensions, gl)\n\n    if (typeof webglVersion === 'number') {\n      this.sceneNode.webglVersion = webglVersion\n    }\n\n    this.sceneNode.clearColor = clearColor\n    this.sceneNode.renderOnUpdate = renderOnUpdate\n\n    if (typeof window === 'object') {\n      // @ts-ignore\n      window.sceneNode = this.sceneNode\n    }\n\n    const update = this.updateDimensions()\n\n    if (update) {\n      this.contextObject = {\n        scene: this.sceneNode,\n        width: update.width,\n        height: update.height,\n      }\n    }\n\n    this.container = ReactVertexReconciler.createContainer(\n      this.sceneNode,\n      false,\n      false,\n    )\n\n    if (this.contextObject) {\n      ReactVertexReconciler.updateContainer(\n        <ReactVertexContext.Provider value={this.contextObject}>\n          {children}\n        </ReactVertexContext.Provider>,\n        this.container,\n        this,\n        () => {},\n      )\n    }\n  }\n\n  componentDidUpdate() {\n    const { children } = this.props\n\n    const dims = this.updateDimensions()\n\n    if (dims && dims.update && this.contextObject) {\n      this.contextObject = {\n        ...this.contextObject,\n        width: dims.width,\n        height: dims.height,\n      }\n    }\n\n    if (this.container && this.contextObject) {\n      ReactVertexReconciler.updateContainer(\n        <ReactVertexContext.Provider value={this.contextObject}>\n          {children}\n        </ReactVertexContext.Provider>,\n        this.container,\n        this,\n        () => {},\n      )\n    }\n  }\n\n  updateDimensions() {\n    const { current } = this.canvas\n\n    if (!current) {\n      return\n    }\n\n    const { width, height, renderOnResize } = this.props\n\n    const devicePixelRatio = window.devicePixelRatio || 1\n\n    const nextWidth = Math.round(width * devicePixelRatio)\n    const nextHeight = Math.round(height * devicePixelRatio)\n\n    const update = nextWidth !== current.width || nextHeight !== current.height\n\n    if (update) {\n      current.style.width = `${width}px`\n      current.style.height = `${height}px`\n      current.width = nextWidth\n      current.height = nextHeight\n\n      renderOnResize && this.sceneNode && this.sceneNode.requestRender()\n    }\n\n    return { width: nextWidth, height: nextHeight, update }\n  }\n\n  renderScene = () => {\n    if (this.sceneNode) {\n      this.sceneNode.render()\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.container) {\n      ReactVertexReconciler.updateContainer(\n        null,\n        this.container,\n        this,\n        () => {},\n      )\n    }\n  }\n\n  render() {\n    const { canvasClass = '', canvasStyle = {} } = this.props\n\n    return (\n      <canvas ref={this.canvas} className={canvasClass} style={canvasStyle} />\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}