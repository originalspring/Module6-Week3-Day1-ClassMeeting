{"ast":null,"code":"// Adapted from:\n// https://github.com/mrdoob/three.js/blob/dev/src/geometries/CylinderGeometry.js\n// @author mrdoob / http://mrdoob.com/\n// @author Mugen87 / https://github.com/Mugen87\n// The MIT License\n// Copyright © 2010-2019 three.js authors\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2\nexport default function cylinderGeometry() {\n  var radiusTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var radiusBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n  var heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var openEnded = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var thetaStart = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var thetaLength = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI * 2;\n  var rSegments = Math.floor(radialSegments || 8);\n  var hSegments = Math.floor(heightSegments || 1);\n  var indices = [];\n  var vertices = [];\n  var normals = [];\n  var uvs = [];\n  var index = 0;\n  var indexArray = [];\n  var halfHeight = height / 2;\n  generateTorso();\n  if (openEnded === false) {\n    if (radiusTop > 0) generateCap(true);\n    if (radiusBottom > 0) generateCap(false);\n  }\n  function generateTorso() {\n    var x, y;\n    var normal = new Array(3);\n    var vertex = new Array(3);\n    var slope = (radiusBottom - radiusTop) / height;\n    for (y = 0; y <= hSegments; y++) {\n      var indexRow = [];\n      var v = y / hSegments;\n      var radius = v * (radiusBottom - radiusTop) + radiusTop;\n      for (x = 0; x <= rSegments; x++) {\n        var u = x / rSegments;\n        var theta = u * thetaLength + thetaStart;\n        var sinTheta = Math.sin(theta);\n        var cosTheta = Math.cos(theta);\n        vertex[0] = radius * sinTheta;\n        vertex[1] = -v * height + halfHeight;\n        vertex[2] = radius * cosTheta;\n        vertices.push.apply(vertices, vertex);\n        normal[0] = sinTheta;\n        normal[1] = slope;\n        normal[2] = cosTheta;\n        var len = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);\n        normal[0] *= 1 / (len || 1);\n        normal[1] *= 1 / (len || 1);\n        normal[2] *= 1 / (len || 1);\n        normals.push.apply(normals, normal);\n        uvs.push(u, 1 - v);\n        indexRow.push(index++);\n      }\n      indexArray.push(indexRow);\n    }\n    for (x = 0; x < rSegments; x++) {\n      for (y = 0; y < hSegments; y++) {\n        var a = indexArray[y][x];\n        var b = indexArray[y + 1][x];\n        var c = indexArray[y + 1][x + 1];\n        var d = indexArray[y][x + 1];\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n  }\n  function generateCap(top) {\n    var x, centerIndexStart, centerIndexEnd;\n    var uv = new Array(2);\n    var vertex = new Array(3);\n    var radius = top === true ? radiusTop : radiusBottom;\n    var sign = top === true ? 1 : -1;\n    centerIndexStart = index;\n    for (x = 1; x <= rSegments; x++) {\n      vertices.push(0, halfHeight * sign, 0);\n      normals.push(0, sign, 0);\n      uvs.push(0.5, 0.5);\n      index++;\n    }\n    centerIndexEnd = index;\n    for (x = 0; x <= rSegments; x++) {\n      var u = x / rSegments;\n      var theta = u * thetaLength + thetaStart;\n      var cosTheta = Math.cos(theta);\n      var sinTheta = Math.sin(theta);\n      vertex[0] = radius * sinTheta;\n      vertex[1] = halfHeight * sign;\n      vertex[2] = radius * cosTheta;\n      vertices.push.apply(vertices, vertex);\n      normals.push(0, sign, 0);\n      uv[0] = cosTheta * 0.5 + 0.5;\n      uv[1] = sinTheta * 0.5 * sign + 0.5;\n      uvs.push.apply(uvs, uv);\n      index++;\n    }\n    for (x = 0; x < rSegments; x++) {\n      var c = centerIndexStart + x;\n      var i = centerIndexEnd + x;\n      if (top === true) {\n        indices.push(i, i + 1, c);\n      } else {\n        indices.push(i + 1, i, c);\n      }\n    }\n  }\n  return {\n    indices: indices,\n    vertices: vertices,\n    normals: normals,\n    uvs: uvs\n  };\n}","map":{"version":3,"mappings":"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","names":["cylinderGeometry","radiusTop","radiusBottom","height","radialSegments","heightSegments","openEnded","thetaStart","thetaLength","Math","PI","rSegments","floor","hSegments","indices","vertices","normals","uvs","index","indexArray","halfHeight","generateTorso","generateCap","x","y","normal","Array","vertex","slope","indexRow","v","radius","u","theta","sinTheta","sin","cosTheta","cos","push","len","sqrt","a","b","c","d","top","centerIndexStart","centerIndexEnd","uv","sign","i"],"sources":["/Users/meishenyin/Desktop/Westcliff/3apps/src/spheres/node_modules/@react-vertex/geometry-hooks/src/cylinderGeometry.ts"],"sourcesContent":["// Adapted from:\n// https://github.com/mrdoob/three.js/blob/dev/src/geometries/CylinderGeometry.js\n\n// @author mrdoob / http://mrdoob.com/\n// @author Mugen87 / https://github.com/Mugen87\n\n// The MIT License\n// Copyright © 2010-2019 three.js authors\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2\n\nexport default function cylinderGeometry(\n  radiusTop: number = 1,\n  radiusBottom: number = 1,\n  height: number = 1,\n  radialSegments: number = 8,\n  heightSegments: number = 1,\n  openEnded: boolean = false,\n  thetaStart: number = 0,\n  thetaLength: number = Math.PI * 2,\n) {\n  const rSegments = Math.floor(radialSegments || 8)\n  const hSegments = Math.floor(heightSegments || 1)\n\n  const indices: number[] = []\n  const vertices: number[] = []\n  const normals: number[] = []\n  const uvs: number[] = []\n\n  let index = 0\n  const indexArray: number[][] = []\n  const halfHeight = height / 2\n\n  generateTorso()\n\n  if (openEnded === false) {\n    if (radiusTop > 0) generateCap(true)\n    if (radiusBottom > 0) generateCap(false)\n  }\n\n  function generateTorso() {\n    let x, y\n\n    const normal = new Array(3)\n    const vertex = new Array(3)\n\n    const slope = (radiusBottom - radiusTop) / height\n\n    for (y = 0; y <= hSegments; y++) {\n      const indexRow = []\n\n      const v = y / hSegments\n      const radius = v * (radiusBottom - radiusTop) + radiusTop\n\n      for (x = 0; x <= rSegments; x++) {\n        const u = x / rSegments\n\n        const theta = u * thetaLength + thetaStart\n\n        const sinTheta = Math.sin(theta)\n        const cosTheta = Math.cos(theta)\n\n        vertex[0] = radius * sinTheta\n        vertex[1] = -v * height + halfHeight\n        vertex[2] = radius * cosTheta\n        vertices.push(...vertex)\n\n        normal[0] = sinTheta\n        normal[1] = slope\n        normal[2] = cosTheta\n\n        const len = Math.sqrt(\n          normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2],\n        )\n\n        normal[0] *= 1 / (len || 1)\n        normal[1] *= 1 / (len || 1)\n        normal[2] *= 1 / (len || 1)\n\n        normals.push(...normal)\n\n        uvs.push(u, 1 - v)\n\n        indexRow.push(index++)\n      }\n\n      indexArray.push(indexRow)\n    }\n\n    for (x = 0; x < rSegments; x++) {\n      for (y = 0; y < hSegments; y++) {\n        const a = indexArray[y][x]\n        const b = indexArray[y + 1][x]\n        const c = indexArray[y + 1][x + 1]\n        const d = indexArray[y][x + 1]\n\n        indices.push(a, b, d)\n        indices.push(b, c, d)\n      }\n    }\n  }\n\n  function generateCap(top: boolean) {\n    let x, centerIndexStart, centerIndexEnd\n\n    const uv = new Array(2)\n    const vertex = new Array(3)\n\n    const radius = top === true ? radiusTop : radiusBottom\n    const sign = top === true ? 1 : -1\n\n    centerIndexStart = index\n\n    for (x = 1; x <= rSegments; x++) {\n      vertices.push(0, halfHeight * sign, 0)\n      normals.push(0, sign, 0)\n      uvs.push(0.5, 0.5)\n\n      index++\n    }\n\n    centerIndexEnd = index\n\n    for (x = 0; x <= rSegments; x++) {\n      const u = x / rSegments\n      const theta = u * thetaLength + thetaStart\n\n      const cosTheta = Math.cos(theta)\n      const sinTheta = Math.sin(theta)\n\n      vertex[0] = radius * sinTheta\n      vertex[1] = halfHeight * sign\n      vertex[2] = radius * cosTheta\n      vertices.push(...vertex)\n\n      normals.push(0, sign, 0)\n\n      uv[0] = cosTheta * 0.5 + 0.5\n      uv[1] = sinTheta * 0.5 * sign + 0.5\n      uvs.push(...uv)\n\n      index++\n    }\n\n    for (x = 0; x < rSegments; x++) {\n      const c = centerIndexStart + x\n      const i = centerIndexEnd + x\n\n      if (top === true) {\n        indices.push(i, i + 1, c)\n      } else {\n        indices.push(i + 1, i, c)\n      }\n    }\n  }\n\n  return { indices, vertices, normals, uvs }\n}\n"]},"metadata":{},"sourceType":"module"}